/**
 * Exporter - Formatação de Exportação
 * Core Logic Layer - Agnóstico ao navegador
 * Versão: 1.0.0
 */

import { CONSTANTS } from '../utils/constants.js';
import { Logger } from '../utils/logger.js';

export class Exporter {
  /**
   * Converte matrizes para formato JSON estruturado
   * @param {Array<UrlMatrix>} matrices - Matrizes a exportar
   * @param {string} exportType - "full" ou "partial"
   * @returns {Object} Objeto JSON versionado
   */
  static toJSON(matrices, exportType = CONSTANTS.EXPORT_TYPES.FULL) {
    Logger.info('Exporting to JSON', { 
      matrixCount: matrices.length,
      exportType: exportType
    });
    
    const flattenedUrls = this.flattenMatrices(matrices);
    
    const exportData = {
      version: CONSTANTS.VERSION,
      generatedAt: new Date().toISOString(),
      source: 'tab-url-extractor',
      metadata: this.buildMetadata(matrices, exportType),
      data: flattenedUrls
    };
    
    Logger.info('JSON export complete', {
      totalUrls: exportData.metadata.totalUrls,
      totalMatrices: exportData.metadata.totalMatrices
    });
    
    return exportData;
  }
  
  /**
   * Converte matrizes para formato TXT simples
   * @param {Array<UrlMatrix>} matrices - Matrizes a exportar
   * @returns {string} Conteúdo TXT formatado
   */
  static toTXT(matrices) {
    Logger.info('Exporting to TXT', { matrixCount: matrices.length });
    
    const lines = [];
    
    // Header com metadados
    lines.push('# Generated by tab-url-extractor');
    lines.push(`# Date: ${new Date().toISOString()}`);
    
    const totalUrls = matrices.reduce((sum, m) => sum + m.urlCount, 0);
    lines.push(`# Total URLs: ${totalUrls}`);
    lines.push(`# Total Matrices: ${matrices.length}`);
    lines.push(`# Export Type: ${matrices.length === 0 ? 'empty' : 'standard'}`);
    lines.push('');
    
    // Matrizes
    matrices.forEach((matrix, index) => {
      lines.push(`# Matrix: ${matrix.label} (${matrix.urlCount} URLs)`);
      
      matrix.urls.forEach(url => {
        lines.push(url.normalizedUrl);
      });
      
      // Linha em branco entre matrizes (exceto última)
      if (index < matrices.length - 1) {
        lines.push('');
      }
    });
    
    const txtContent = lines.join('\n');
    
    Logger.info('TXT export complete', {
      totalUrls: totalUrls,
      lineCount: lines.length
    });
    
    return txtContent;
  }
  
  /**
   * Converte matrizes para formato TXT simples (apenas URLs, sem headers)
   * @param {Array<UrlMatrix>} matrices - Matrizes a exportar
   * @returns {string} Conteúdo TXT apenas com URLs
   */
  static toTXT_Simple(matrices) {
    Logger.info('Exporting to TXT Simple', { matrixCount: matrices.length });
    
    const urls = [];
    
    // Apenas URLs normalizadas, uma por linha
    matrices.forEach(matrix => {
      matrix.urls.forEach(url => {
        urls.push(url.normalizedUrl);
      });
    });
    
    const txtContent = urls.join('\n');
    
    Logger.info('TXT Simple export complete', {
      totalUrls: urls.length
    });
    
    return txtContent;
  }
  
  /**
   * Constrói objeto de metadados
   * @param {Array<UrlMatrix>} matrices - Matrizes
   * @param {string} exportType - Tipo de exportação
   * @returns {Object} Objeto de metadados
   */
  static buildMetadata(matrices, exportType) {
    const totalUrls = matrices.reduce((sum, m) => sum + m.urlCount, 0);
    
    const metadata = {
      totalUrls: totalUrls,
      totalMatrices: matrices.length,
      exportType: exportType
    };
    
    // Adiciona matrixIds apenas para exportação parcial
    if (exportType === CONSTANTS.EXPORT_TYPES.PARTIAL) {
      metadata.matrixIds = matrices.map(m => m.id);
    }
    
    return metadata;
  }
  
  /**
   * Flatten de matrizes em array de URLs
   * @param {Array<UrlMatrix>} matrices - Matrizes
   * @returns {Array<Object>} Array de objetos de URL
   */
  static flattenMatrices(matrices) {
    const flattened = [];
    
    matrices.forEach(matrix => {
      matrix.urls.forEach(url => {
        flattened.push({
          url: url.url,
          normalizedUrl: url.normalizedUrl,
          domain: url.domain,
          origin: url.origin,
          matrixId: matrix.id,
          matrixLabel: matrix.label
        });
      });
    });
    
    return flattened;
  }
  
  /**
   * Converte para CSV (futuro)
   * @param {Array<UrlMatrix>} matrices - Matrizes
   * @returns {string} Conteúdo CSV
   */
  static toCSV(matrices) {
    Logger.info('Exporting to CSV', { matrixCount: matrices.length });
    
    const lines = [];
    
    // Header
    lines.push('url,normalized_url,domain,origin,matrix_id,matrix_label');
    
    // Dados
    const flattenedUrls = this.flattenMatrices(matrices);
    flattenedUrls.forEach(item => {
      const row = [
        this.escapeCSV(item.url),
        this.escapeCSV(item.normalizedUrl),
        this.escapeCSV(item.domain),
        this.escapeCSV(item.origin),
        this.escapeCSV(item.matrixId),
        this.escapeCSV(item.matrixLabel)
      ];
      lines.push(row.join(','));
    });
    
    return lines.join('\n');
  }
  
  /**
   * Escapa valor para CSV
   * @param {string} value - Valor a escapar
   * @returns {string} Valor escapado
   */
  static escapeCSV(value) {
    if (!value) return '';
    
    const stringValue = String(value);
    
    // Se contém vírgula, aspas ou quebra de linha, envolve em aspas
    if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
      return `"${stringValue.replace(/"/g, '""')}"`;
    }
    
    return stringValue;
  }
  
  /**
   * Valida formato de exportação
   * @param {string} format - Formato solicitado
   * @returns {boolean} true se válido
   */
  static isValidFormat(format) {
    return (
      format === CONSTANTS.EXPORT_FORMATS.JSON ||
      format === CONSTANTS.EXPORT_FORMATS.TXT ||
      format === CONSTANTS.EXPORT_FORMATS.TXT_SIMPLE
    );
  }
  
  /**
   * Converte matrizes para o formato especificado
   * @param {Array<UrlMatrix>} matrices - Matrizes
   * @param {string} format - Formato ("json", "txt" ou "txt-simple")
   * @param {string} exportType - Tipo de exportação
   * @returns {string|Object} Conteúdo formatado
   * @throws {Error} Se formato for inválido
   */
  static export(matrices, format, exportType = CONSTANTS.EXPORT_TYPES.FULL) {
    if (!this.isValidFormat(format)) {
      throw new Error(`Invalid format: ${format}`);
    }
    
    switch (format) {
      case CONSTANTS.EXPORT_FORMATS.JSON:
        return this.toJSON(matrices, exportType);
      
      case CONSTANTS.EXPORT_FORMATS.TXT:
        return this.toTXT(matrices);
      
      case CONSTANTS.EXPORT_FORMATS.TXT_SIMPLE:
        return this.toTXT_Simple(matrices);
      
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }
}

// Exportação default para compatibilidade
export default Exporter;
